---
layout: post
title: 动态链接共享库
author: Triangleowl
categories: linux
permlink: /categories/:title
---

### [共享库的优点](#共享库的优点)
和静态库相比，共享库主要有一下几个优点：  
* 维护方便。静态库和所有软件一样，也需要定期维护和更新，如果程序是以静态方式链接的，则每次修改
库都需要重新编译并链接。如果程序很大，则编译和链接都很费时间。但是如果使用共享库则完全不存在这
个问题，只要更新共享库就行了，程序运行是会共享的加载更新过的库。

* 节省内存。基本上每个程序C程序都使用标准I/O函数，比如`printf`、`scanf`等。在运行程序时这些代码都
会被加载到每个进程的代码段中。如果有几百个程序都用到了某个库中的同一个函数，则需要将同一段代码加载
几百份到内存中，这样做极其浪费宝贵的内存资源。而使用共享库则只需要加载一份代码到内存中。

共享库的出现解决了静态库的缺陷，共享库是一个`目标模块`，只有在用到的时候才会加载，而且可以加载到任意
地址，并且和正在内存中运行的进程链接起来。

### [位置无关代码](#位置无关代码)
共享库的一个主要目标就是允许多个进程共享加载到内存的相同代码库，从而节约宝贵的内存资源。那么进程间
是如何共享同一段代码的呢？一个简单的方法是给每个库分配一个专用的地址空间，然后加载器就按照分配的地址
将代码加载到内存中。但是问题又来了，如果一个库修改之后占用的内存空间变大了，这是就要考虑原来计划分配
的地址空间还适合修改之后的大小，如果不合适则要重新分配内存空间。如果有几百个库，则库的内存管理则变成
一个十分棘手的问题。  

共享代码也有一个很大的问题，那就是共享代码也要处理数据，而数据存在内存中。如果多个进程共享库中的代码
和库的数据，那么不同进程对数据进行不同的操作，最后的结果就使数据乱套。所以每个进程只能共享库的代码，
而不能共享库的数据。因为代码只具有`R-E`属性，虽然多个进程可以同时使用一份代码，但是不能修改代码，而
每个进程都有一份自己的数据来公共享代码访问，这样就能保证数据的安全和准确。

但是问题又来了：既不能修改代码又要保证每个进程使用的共享库代码访问的是自己的数据。如何做到这一点呢？
如果无法解决这个问题就无法实现位置无关代码(Position-Independent Code，PIC)。实现PIC就要借助`GOT`和
`PLT`。具体内容可以参考：[位置无关代码](https://triangleowl.github.io/linux/2019/11/06/Position-Independent-Code.html)
